diff --git a/src/cli.rs b/src/cli.rs
index 9597aac..a5fc555 100644
--- a/src/cli.rs
+++ b/src/cli.rs
@@ -2,3 +2,5 @@ use crate::{
     app::App,
+    cache::Cacheable,
     config::{default_config_file, default_config_toml, AppConfig, UserConfig},
+    source::Source,
     tui,
@@ -7,3 +9,3 @@ use clap::{Parser, Subcommand, ValueEnum};
 use color_eyre::eyre::Result;
-use std::{io::Write, path::PathBuf};
+use std::{io::Write, path::PathBuf, thread};
 use tracing::debug;
@@ -25,2 +27,37 @@ impl Cli {
     pub(crate) fn run(self, config: &'static AppConfig) -> Result<()> {
+        if config.prewarm_cache {
+            println!("Pre-warming cache for all sources...");
+
+            let sources: Vec<Source> = config.sources.iter().map(Source::from).collect();
+            let mut handles = vec![];
+
+            for source in sources {
+                let cache_path = source.cache_path(config);
+                let handle = thread::spawn(move || {
+                    let res = source.get_expensive();
+                    match res {
+                        Ok(data) => {
+                            if let Some(path) = cache_path {
+                                match Source::store_cache(&data, &path) {
+                                    Ok(_) => println!("Successfully cached '{}'", source),
+                                    Err(e) => {
+                                        eprintln!("Failed to cache '{}': {}", source, e)
+                                    }
+                                }
+                            }
+                        }
+                        Err(e) => eprintln!("Failed to fetch data for '{}': {}", source, e),
+                    }
+                });
+                handles.push(handle);
+            }
+
+            for handle in handles {
+                handle.join().unwrap();
+            }
+
+            println!("Cache pre-warming complete.");
+            return Ok(());
+        }
+
         match self.command {
diff --git a/src/config/app_config.rs b/src/config/app_config.rs
index 5b03fc9..1c5ed96 100644
--- a/src/config/app_config.rs
+++ b/src/config/app_config.rs
@@ -11,2 +11,3 @@ pub(crate) struct AppConfig {
     pub(crate) sources: Vec<SourceConfig>,
+    pub(crate) prewarm_cache: bool,
     pub(crate) cache_duration: Option<std::time::Duration>,
@@ -21,2 +22,3 @@ impl From<UserConfig> for AppConfig {
             sources: value.sources,
+            prewarm_cache: value.prewarm_cache,
             cache_duration: if value.auto_refresh_cache {
@@ -47,2 +49,3 @@ impl From<AppConfig> for UserConfig {
             auto_refresh_cache: value.cache_duration.is_some(),
+            prewarm_cache: value.prewarm_cache,
             cache_duration: value.cache_duration.unwrap_or_default(),
diff --git a/src/config/user_config.rs b/src/config/user_config.rs
index 7afe31c..1fc9c55 100644
--- a/src/config/user_config.rs
+++ b/src/config/user_config.rs
@@ -23,2 +23,3 @@ pub(crate) struct UserConfig {
     pub(super) cache_duration: std::time::Duration,
+    pub(super) prewarm_cache: bool,
     pub(super) cache_dir: PathBuf,
@@ -49,2 +50,3 @@ impl Default for UserConfig {
             cache_duration: Duration::from_secs(7 * 24 * 60 * 60),
+            prewarm_cache: false,
             cache_dir: project_paths::default_cache_dir().clone(),
@@ -89,2 +91,5 @@ cache_duration = "1week"
 
+# If true, update the cache for all sources and exit.
+prewarm_cache = false
+
 # Directory in which to store cached results
diff --git a/src/config/user_config/tests.rs b/src/config/user_config/tests.rs
index c140a8c..9adc8c3 100644
--- a/src/config/user_config/tests.rs
+++ b/src/config/user_config/tests.rs
@@ -49,2 +49,3 @@ fn roundtrip_linux_paths() -> Result<()> {
         cache_duration: Duration::from_secs(7 * 24 * 60 * 60),
+        prewarm_cache: false,
         cache_dir: PathBuf::from_str("/home/runneradmin/.cache/nox")?,
@@ -68,2 +69,3 @@ fn parse_toml_linux_paths() -> Result<()> {
     let toml = r#"
+prewarm_cache = false
 use_cache = true
@@ -126,2 +128,3 @@ fn roundtrip_mixed_paths_windows() -> Result<()> {
         cache_duration: Duration::from_secs(7 * 24 * 60 * 60),
+        prewarm_cache: false,
         cache_dir: PathBuf::from_str(r"C:\home/runneradmin/.cache/nox")?,
diff --git a/src/source.rs b/src/source.rs
index 8218ac9..583fa28 100644
--- a/src/source.rs
+++ b/src/source.rs
@@ -1,3 +1,3 @@
 use crate::cache::Cacheable;
-use crate::config::SourceConfig;
+use crate::config::{AppConfig, SourceConfig};
 use crate::parsing::{parse_options, parse_version, OptText};
@@ -8,5 +8,7 @@ use serde::{Deserialize, Serialize};
 use std::fmt;
+use std::fs;
+use std::path::{Path, PathBuf};
 use tracing::{error, instrument};
 
-#[derive(Debug, Clone, Encode, Decode, PartialEq, Deserialize, Serialize)]
+#[derive(Debug, Clone, Encode, Decode, PartialEq, Deserialize,Serialize)]
 pub(crate) struct Source {
@@ -41,2 +43,9 @@ impl Source {
 
+    pub(crate) fn cache_path(&self, config: &AppConfig) -> Option<PathBuf> {
+        config
+            .cache_dir
+            .as_ref()
+            .map(|d| d.join(format!("{}.zst", self.inner.name)))
+    }
+
     pub(crate) fn url(&self) -> &str {
@@ -54,2 +63,6 @@ impl Source {
     pub(crate) fn get_data_html(&self) -> Result<String> {
+        if self.url().starts_with("file://") {
+            let path = Path::new(self.url().strip_prefix("file://").unwrap());
+            return Ok(fs::read_to_string(path)?);
+        }
         Ok(ureq::get(self.url())
@@ -65,2 +78,6 @@ impl Source {
     pub(crate) fn get_version_html(&self) -> Result<String> {
+        if self.version_url().starts_with("file://") {
+            let path = Path::new(self.version_url().strip_prefix("file://").unwrap());
+            return Ok(fs::read_to_string(path)?);
+        }
         Ok(ureq::get(self.version_url())
